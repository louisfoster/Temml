let defineFunctionBuilders,getVariant,variantChar,smallCaps,mathMLTree,mml;_e66‍.w("../defineFunction",[["defineFunctionBuilders",["defineFunctionBuilders"],function(v){defineFunctionBuilders=v}]]);_e66‍.w("../variant",[["getVariant",["getVariant"],function(v){getVariant=v}]]);_e66‍.w("../replace",[["variantChar",["variantChar"],function(v){variantChar=v}],["smallCaps",["smallCaps"],function(v){smallCaps=v}]]);_e66‍.w("../mathMLTree",[["default",["mathMLTree"],function(v){mathMLTree=v}]]);_e66‍.w("../buildMathML",[["*",null,function(v){mml=v}]]);





// "mathord" and "textord" ParseNodes created in Parser.js from symbol Groups in
// src/symbols.js.

const numberRegEx = /^\d(?:[\d,.]*\d)?$/  // Keep in sync with numberRegEx in Parser.js

const latinRegEx = /[A-Ba-z]/

const italicNumber = (text, variant) => {
  const mn = new mathMLTree.MathNode("mn", [text])
  const wrapper = new mathMLTree.MathNode("mstyle", [mn])
  wrapper.style["font-style"] = "italic"
  wrapper.style["font-family"] = "Cambria, 'Times New Roman', serif"
  if (variant === "bold-italic") { wrapper.style["font-weight"] = "bold" }
  return wrapper
}

defineFunctionBuilders({
  type: "mathord",
  mathmlBuilder(group, style) {
    const text = mml.makeText(group.text, group.mode, style)
    const codePoint = text.text.codePointAt(0)
    // Test for upper-case Greek
    const defaultVariant = (0x0390 < codePoint && codePoint < 0x03aa) ? "normal" : "italic"
    const variant = getVariant(group, style) || defaultVariant
    if (variant === "script") {
      text.text = variantChar(text.text, variant)
      return new mathMLTree.MathNode("mi", [text], [style.font])
    } else if (variant !== "italic") {
      text.text = variantChar(text.text, variant)
    }
    let node = new mathMLTree.MathNode("mi", [text])
    // TODO: Handle U+1D49C - U+1D4CF per https://www.unicode.org/charts/PDF/U1D400.pdf
    if (variant === "normal") {
      node.setAttribute("mathvariant", "normal")
      if (text.text.length === 1) {
        // A Firefox bug will apply spacing here, but there should be none. Fix it.
        node = new mathMLTree.MathNode("mpadded", [node])
        node.setAttribute("lspace", "0")
        node.setAttribute("width", "+0em")
      }
    }
    return node
  }
})

defineFunctionBuilders({
  type: "textord",
  mathmlBuilder(group, style) {
    let ch = group.text
    const codePoint = ch.codePointAt(0)
    if (style.fontFamily === "textsc") {
      // Convert small latin letters to small caps.
      if (96 < codePoint && codePoint < 123) {
        ch = smallCaps[ch]
      }
    }
    const text = mml.makeText(ch, group.mode, style)
    const variant = getVariant(group, style) || "normal"

    let node
    if (group.mode === "text") {
      if (variant === "italic" || variant === "bold-italic") {
        if (numberRegEx.test(group.text)) {
          return italicNumber(text, variant)
        }
      }
      if (variant !== "normal") {
        text.text = variantChar(text.text, variant)
      }
      node = new mathMLTree.MathNode("mtext", [text])
    } else if (numberRegEx.test(group.text)) {
      if (variant === "oldstylenums") {
        const ms = new mathMLTree.MathNode("mstyle", [text], ["oldstylenums"])
        node = new mathMLTree.MathNode("mn", [ms])
      } else if (variant === "italic" || variant === "bold-italic") {
        return italicNumber(text, variant)
      } else {
        if (variant !== "normal") {
          text.text = text.text.split("").map(c => variantChar(c, variant)).join("")
        }
        node = new mathMLTree.MathNode("mn", [text])
      }
    } else if (group.text === "\\prime") {
      node = new mathMLTree.MathNode("mo", [text])
    } else {
      const origText = text.text
      if (variant !== "italic") {
        text.text = variantChar(text.text, variant)
      }
      node = new mathMLTree.MathNode("mi", [text])
      if (text.text === origText && latinRegEx.test(origText)) {
        node.setAttribute("mathvariant", "italic")
      }
    }
    return node
  }
})
