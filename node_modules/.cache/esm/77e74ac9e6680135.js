let defineFunction,StyleLevel,mathMLTree,assertNodeType,calculateSize,mml;_e66‍.w("../defineFunction",[["default",["defineFunction"],function(v){defineFunction=v}]]);_e66‍.w("../constants",[["StyleLevel",["StyleLevel"],function(v){StyleLevel=v}]]);_e66‍.w("../mathMLTree",[["default",["mathMLTree"],function(v){mathMLTree=v}]]);_e66‍.w("../parseNode",[["assertNodeType",["assertNodeType"],function(v){assertNodeType=v}]]);_e66‍.w("../units",[["calculateSize",["calculateSize"],function(v){calculateSize=v}]]);_e66‍.w("../buildMathML",[["*",null,function(v){mml=v}]]);






const sign = num => num >= 0 ? "+" : "-"

// \raise, \lower, and \raisebox

const mathmlBuilder = (group, style) => {
  const newStyle = style.withLevel(StyleLevel.TEXT)
  const node = new mathMLTree.MathNode("mpadded", [mml.buildGroup(group.body, newStyle)])
  const dy = calculateSize(group.dy, style)
  node.setAttribute("voffset", dy.number + dy.unit)
  const dyAbs = Math.abs(dy.number)
  node.setAttribute("height", sign(dy.number) +  dyAbs + dy.unit)
  node.setAttribute("depth", sign(-dy.number) +  dyAbs + dy.unit)
  return node
}

defineFunction({
  type: "raise",
  names: ["\\raise", "\\lower"],
  props: {
    numArgs: 2,
    argTypes: ["size", "primitive"],
    primitive: true
  },
  handler({ parser, funcName }, args) {
    const amount = assertNodeType(args[0], "size").value;
    if (funcName === "\\lower") { amount.number *= -1 }
    const body = args[1]
    return {
      type: "raise",
      mode: parser.mode,
      dy: amount,
      body
    };
  },
  mathmlBuilder
})


defineFunction({
  type: "raise",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const amount = assertNodeType(args[0], "size").value
    const body = args[1]
    return {
      type: "raise",
      mode: parser.mode,
      dy: amount,
      body
    };
  },
  mathmlBuilder
})

